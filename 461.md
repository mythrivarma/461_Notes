# 461_Notes - Querying SQL Server #
**Current Status - Page No : 70**
* Check the differences between CONVERT, CAST, PARSE. Also check the TRY_ versions of the same.
* Try to Answer Qs in Sql Query Form in Technet (in your T-sql Bookmarks)
* Revisit page 42,43 after completing Chapters 11 and 15
 
##Chapter 1 (Foundations of Querying)##
* Here is the logical query processing order of the six main query clauses:
 * FROM
 * WHERE
 * GROUP BY
 * HAVING
 * SELECT
 * ORDER BY

* Date Time Columns can be queried like this:
WHERE hiredate >= '20030101'
* ORDER BY clause is the first and only clause (Top/Distinct?) that is allowed to refer to column
aliases defined in the SELECT clause. That’s because the ORDER BY clause is the only one
to be evaluated after the SELECT clause
* You cannot use ORDER BY on columns that have the text, ntext, image, or xml data types.
* One of most typical mistakes that T-SQL developers make is to assume that a query without an ORDER BY clause always returns the data in a certain order—for example, clustered index order. But if you understand that in set theory, a set has no particular order to its elements, you know that you shouldn’t make such assumptions. The only way in SQL to guarantee that the rows will be returned in a certain order is to add an ORDER BY clause. That’s just one of many examples for aspects of T-SQL that can be better understood if you understand the foundations of the language. Now, you know that why a view created with an order by clause, does not guarantee any order when we query it with out an order by clause.

##Chapter 2 (Getting Started with SELECT Statement)##
* There are a number of supported forms of aliasing: <expression> AS <alias>
as in empid AS employeeid, <expression> <alias> as in empid employeeid, and <alias> =
<expression> as in employeeid = empid
* If a Table name starts with a numeric value(or has an embedded space, or is a reserved T-SQL
keyword), then delimiters ("" or []) should be used while querying it.
* Float and Real are the datatypes with Maximum Range of values in numbers. But they are not recommended when we need accurate values. Accuracy takes a hit while using these data types.
* Fixed types use the storage for the indicated size; for example, CHAR(30) uses storage for 30 characters, whether
you actually specify 30 characters or less. This means that updates will not require the row to physically expand, and therefore no data shifting is required. So for attributes that get updated frequently, where the update performance is a priority, you should consider fixed types. Note that when compression is used—specifically row compression—SQL Server stores fixed types like variable ones, but with less overhead.
* With character strings, there’s also the question of using regular character types (CHAR,VARCHAR) vs. Unicode types (NCHAR, NVARCHAR). The former use 1 byte of storage per character and support only one language (based on collation properties) besides English. The latter use 2 bytes of storage per character (unless compressed) and support multiple languages.
* You also want to make sure that when indicating a literal of a type, you use the correct form. For example, literals of regular character strings are delimited with single quotation marks, as in 'abc', whereas literals of Unicode character strings are delimited with a capital N and then single quotation marks, as in N'abc'.
* As for the difference between CAST, CONVERT, and PARSE, with CAST, you indicate the expression and the target type; with CONVERT, there’s a third argument representing the style for the conversion, which is supported for some conversions, like between character strings and date and time values. For example, CONVERT(DATE, '1/2/2012', 101) converts the literal character string to DATE using style 101 representing the United States standard. With PARSE, you can indicate the culture by using any culture supported by the Microsoft .NET Framework. For example, PARSE('1/2/2012' AS DATE USING 'en-US') parses the input literal as a DATE by using a United States English culture.
* When using expressions that involve operands of different types, SQL Server usually converts the one that has the lower data type precedence to the one with the higher. Consider the expression 1 + '1' as an example. One operand is INT and the other is VARCHARINT precedes VARCHAR; hence, SQL Server implicitly converts the VARCHAR value '1' to the INT value 1, and the
result of the expression is therefore 2 and not the string '11'.
* Nonsequential GUIDs: You can generate nonsequential global unique identifiers to be stored in an attribute of a UNIQUEIDENTIFIER type. You can use the T-SQL function NEWID to generate a new GUID.
* Sequential GUIDs: You can generate sequential GUIDs within the machine by using the T-SQL function NEWSEQUENTIALID.
* using functions in JOIN (ON) clause will not use indexes properly so avoid them . Example: instead of using ISNULL(A.Col1, -1) = ISNULL(B.Col1, -1) , use A.Col1 = B.Col1 OR (A.Col1 IS NULL AND B.Col1 IS NULL). Another Example is to use LIKE 'ABC%' instead of LEFT(Col,3)='ABC'. However, remember LIKE '%ABC%' will not use Index. Only LIKE 'ABC%' does.
* While doing a SELECT ISNULL(Col1,'') as A, COALESCE(Col1,'') as B INTO ,if the source attribute 'col1' is defined as allowing NULLs, COALESCE will create a result attribute allowing NULLs, whereas ISNULL will create one that disallows NULLs.
* NULLIF function accepts two input expressions, returns NULL if they are equal, and returns the first input if they are not.
* The expression CHOOSE(2, 'x', 'y', 'z') returns 'y'. Again, it’s straightforward to replace a CHOOSE expression with a logically equivalent CASE expression; but the point in supporting CHOOSE, as well as IIF, is to simplify migrations from Access to SQL Server as a temporary solution.
* The + operator by default yields a NULL result on NULL input, whereas the CONCAT function treats NULLs as empty strings.
* DATEFROMPARTS() is new function in SQL Server 2012. Absent in 2008.
* Use REPLICATE function to pad repetitive text.
* Understand FORMAT() function correctly and look at Question 2 in Page54-55
* There are two kinds of CASE() Expressions. SIMPLE and SEARCHED. 
* To improve the portability of the code, it’s important to use standard code when possible, and this of course applies more specifically to the use of built-in functions. For example, use COALESCE and not ISNULL, use CURRENT_TIMESTAMP and not GETDATE, and use CASE and not IIF
* Data Type Precedence https://msdn.microsoft.com/en-us/library/ms190309.aspx
* Date Time Functions https://msdn.microsoft.com/en-us/library/ms186724
* String Functions https://msdn.microsoft.com/en-us/library/ms181984

##Chapter 3 (Filtering and Sorting Data)##
* Country = 'USA' gives all records having USA as Country. Country <> 'USA' does not give all other records. It will eliminate records where Country IS NULL. THis is because the logic is Three way (TRUE, FALSE, UNKNOWN) and only TRUE records are passed. the soultion is to use Country <> 'USA' OR Country IS NULL 
* Negation of true and false is straightforward—NOT true is false, and NOT false is true. What can be surprising to some is what happens when you negate unknown—NOT unknown is still unknown.
*  The NOT operator precedes AND and OR, and AND precedes OR (like BODMAS for Numbers). Parentheses have the highest precedence among all operators
*  THEORY: Unless precedence rules dictate otherwise, predicates will be evaluated from left to right, and that short circuiting will take place when possible. In other words, if the Where Cond is Country = 'USA' AND Region = 'WA', if Country is not USA, the query will not check for Region. REALITY: The reality, though, is different. SQL Server does internally support a short-circuit concept; however, due to the all-at-once concept in the language, it is not necessarily going to
evaluate the expressions in left-to-right order. It could decide, based on cost-related reasons, to start with the second expression, and then if the second expression evaluates to true, to evaluate the first expression as well.
*  It’s a very typical bad habit to specify a regular character string literal when the filtered column is of a Unicode type. Example: Country = 'USA' instead of using Country = N'USA' when country is NVARCHAR. SQL Server implicitly converts one
operand’s type to the other. In this example, fortunately, SQL Server converts the literal’s type to the column’s type, so it can still efficiently rely on indexing.
*  If you want to look for a character that is considered a wildcard, you can indicate it after a character that you designate as an escape character by using the ESCAPE keyword.
*  the form '20070212' is always interpreted as ymd, regardless of your language (English(mdy), UK(dmy), Japanese(ymd)).
*  Note that the form '2007-02-12' is considered language-neutral only for the data types DATE, DATETIME2, and DATETIMEOFFSET. Unfortunately, due to historic reasons, this form is considered language-dependent for the types DATETIME and SMALLDATETIME.
* WHERE orderdate BETWEEN '20080211' AND '20080212 23:59:59.999'; Because 999 is not a multiplication of the DATETIME type’s precision unit (three and a third milliseconds), the end value in the range gets rounded to the next midnight, and the result includes rows from February 13 that you didn’t ask for.
* you can order the result rows by elements that are not part of the SELECT list, as long as the result rows would have normally been allowed there. So due to this reason, for Distinct and Group BY Clauses, we cannot use columns that are not in select clause, in the ORDER BY CLause
* Standard SQL says that NULLs should sort together, but leaves it to the implementation to decide whether to sort them before or after non-NULL values. In SQL Server the decision was to sort them before non-NULLs (when using an ascending direction). Standard SQL supports the options NULLS FIRST and NULLS LAST to control how NULLs sort, but T-SQL doesn’t support this option.
* According to standard SQL, a query with an ORDER BY clause conceptually returns a cursor and not a relation. So remember, a query without an ORDER BY clause returns a relational result (at least froman ordering perspective), and hence doesn’t guarantee any order.
* TOP() function is applied after Order By. So the order is DISTINCT, ORDER BY , TOP. the function takes BIGINT as input parameter. PERCENT When used along with TOP will give top N % of rows. 
* One option is to ask to include all ties with the last row (while using ORDER BY) is by adding the WITH TIES option along with TOP. TOP N WITH TIES can return more than N Records.  
* TOP option can also be used in modification statements to limit how many rows get modified
* The OFFSET-FETCH option is a filtering option that, like TOP, you can use to filter data based on a specified number of rows and ordering. But unlike TOP, it is standard, and also has a skipping capability, making it useful for ad-hoc paging purposes. OFFSET 50 ROWS FETCH NEXT 25 ROWS ONLY; OFFSET 0 ROWS FETCH FIRST 25 ROWS ONLY; observe why First and Next are used appropriately in the two statements. ROW or ROWS both will work in this statment and no errors will be thrown.
* in T-SQL, the OFFSET-FETCH option requires an ORDER BY clause to be present. Also, in T-SQL—contrary to standard SQL—a FETCH clause requires an OFFSET clause to be present. however, the OFFSET clause doesn’t require a FETCH clause.
*  the OFFSET-FETCH option requires an ORDER BY clause. But what if you need to filter a certain number of rows based on arbitrary order? To do so, you can specify the expression (SELECT NULL) in the ORDER BY clause.
*  TOP and OFFSET-FETCH cannot be combined in the same query

##Chapter 1 (Combining Sets)##
*






